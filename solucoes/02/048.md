## Problema

48 - Cria as seguintes classes:

* Classe `AddManager`, com uma propriedade só de leitura de nome `Total` do
  tipo `int` (suportada numa variável de instância privada de nome `total`), e
  com um método `AddToTotal()`, que aceita um inteiro e adiciona-o à variável
  `total`. Esta classe deve ser um _singleton_ com inicialização _lazy_, e
  tanto a sua inicialização como a modificação da variável `total` (dentro do
  método `AddToTotal()`) devem ser _thread-safe_.
* Classe `Adder`, com o método `LetsAdd()`, que cria e lança uma _thread_ que
  invoca 1000 vezes o método `AddToTotal()` da instância solitária de
  `AddManager`, passando-lhe inteiros aleatórios entre 0 e 100. A classe tem
  também a propriedade auto-implementada `Partial`, na qual a _thread_ guarda
  o total parcial relativo aos inteiros que somou. O método `LetsAdd()`
  retorna a instância da _thread_ criada e lançada.
* Classe `Program`, com o método `Main()`, no qual: a) são criadas 20
  instâncias de `Adder`; b) é invocado o método `LetsAdd()` em cada delas,
  sendo mantidas referência às _threads_ devolvidas; c) é feita uma espera
  (com _join_) em todas as _threads_ devolvidas; d) é realizada e mostrada no
  ecrã a soma do `Partial` de todas as instâncias de `Adder`; e) é mostrado
  no ecrã o valor `Total` da instância solitária de `AddManager`; e, f) é
  indicado no ecrã se as somas são iguais ou não.

Nota que, para o programa estar correto, as somas devem ser sempre iguais.

## Soluções

### Solução 1

**AddManager.cs**

```cs
public class AddManager
{
    private static readonly object lockObject = new object();
    private static readonly Lazy<AddManager> singleInstance =
        new Lazy<AddManager>(() => new AddManager());
    public int Total => total;
    private int total;
    public static AddManager SingleInstance => singleInstance.Value;
    public void AddToTotal(object value)
    {
        lock (lockObject)
        {
            total += (int)value;
        }
    }
}
```

**Adder.cs**

```cs
using System.Threading;

public class Adder
{
    public Thread t;
    public static int Partial { get; set; }
    public Thread LetsAdd(AddManager addManager)
    {
        Random rnd = new Random();
        for (int index = 0; index < 1000; index++)
        {
            t = new Thread(addManager.AddToTotal);
            int valueToAdd = rnd.Next(0, 101);
            t.Start(valueToAdd);
            Partial += valueToAdd;
        }
        return t;
    }
}
```

**Program.cs**

```cs
using System.Threading;

class Program
{
    static void Main(string[] args)
    {
        AddManager addManager = new AddManager();
        // a)
        List<Adder> adderList = new List<Adder>();
        for (int index = 0; index < 20; index++)
            adderList.Add(new Adder());
        // b)
        List<Thread> threadsFromAdder = new List<Thread>();
        foreach (Adder adder in adderList)
        {
            adder.LetsAdd(addManager);
            threadsFromAdder.Add(adder.t);
        }
        // c)
        foreach (Adder adder in adderList)
            adder.t.Join();
        // d)
        Console.WriteLine(Adder.Partial);
        // e)
        Console.WriteLine(addManager.Total);
        // f)
        if (Adder.Partial == addManager.Total)
            Console.WriteLine("As somas são iguais.");
        else
            Console.WriteLine("As somas não são iguais.");
    }
}
```

*Por [Inácio Amerio](https://github.com/fpthefluffypawed).*